<!DOCTYPE concept PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept xmlns:ditaarch="http://dita.oasis-open.org/architecture/2005/" id="concept-8077" domains="(topic concept)                            (topic hi-d)                            (topic ut-d)                            (topic indexing-d)                             (topic pr-d)                            (topic sw-d)                            (topic ui-d)   " ditaarch:DITAArchVersion="1.2" class="- topic/topic concept/concept "><title class="- topic/title ">Secure coding practices for tasks</title><shortdesc class="- topic/shortdesc ">Use secure coding practices when you write tasks and help protect your system. </shortdesc><prolog class="- topic/prolog "><author type="creator" translate="no" class="- topic/author ">Kate Lopresti &lt;kate.lopresti@puppet.com&gt;</author></prolog><conbody class="- topic/body  concept/conbody "><p class="- topic/p "><note type="note" class="- topic/note ">The information in this topic covers basic coding practices for writing secure tasks. It is not an exhaustive list.</note></p><p class="- topic/p "> One of the methods attackers use to gain access to your systems is remote code execution, where by running an allowed script they gain access to other parts of the system and can make arbitrary changes. Because <ph conkeyref="ProductNames/bolt" class="- topic/ph "/> executes scripts across your infrastructure, it is important to be aware of certain vulnerabilities, and to code tasks in a way that guards against remote code execution. </p><p class="- topic/p ">Adding task metadata that validates input is one way to reduce vulnerability. When you require an enumerated (<codeph translate="no" class="+ topic/ph pr-d/codeph ">enum</codeph>) or other non-string types, you prevent improper data from being entered. An arbitrary string parameter does not have this assurance. </p><p class="- topic/p ">For example, if your task has a parameter that selects from several operational modes that are passed to a shell command, instead of </p><codeblock translate="no" xml:space="preserve" class="+ topic/pre pr-d/codeblock ">String $mode = 'file'</codeblock><p class="- topic/p ">use</p><codeblock translate="no" xml:space="preserve" class="+ topic/pre pr-d/codeblock ">Enum[file,directory,link,socket] $mode = file</codeblock><p class="- topic/p ">If your task has a parameter that identifies a file on disk, ensure that a user can't specify a relative path that takes them into areas where they shouldn't be. Reject file names that have slashes. </p><p class="- topic/p ">Instead of </p><codeblock translate="no" xml:space="preserve" class="+ topic/pre pr-d/codeblock ">String $path</codeblock><p class="- topic/p ">use</p><codeblock translate="no" xml:space="preserve" class="+ topic/pre pr-d/codeblock ">Pattern[/\A[^\/\\]*\z/] $path</codeblock><p class="- topic/p ">In addition to these task restrictions, different scripting languages each have their own ways to validate user input. </p><section class="- topic/section "><title class="- topic/title "> <ph conkeyref="ProductNames/powershell" class="- topic/ph "/> </title><p class="- topic/p ">In <ph conkeyref="ProductNames/powershell" class="- topic/ph "/>, code injection exploits calls that specifically evaluate code. Do not call <codeph translate="no" class="+ topic/ph pr-d/codeph ">Invoke-Expression</codeph> or <codeph translate="no" class="+ topic/ph pr-d/codeph ">Add-Type</codeph> with user input. These commands evaluate strings as C# code.</p><p class="- topic/p ">Reading sensitive files or overwriting critical files can be less obvious. If you plan to allow users to specify a file name or path, use <codeph translate="no" class="+ topic/ph pr-d/codeph ">Resolve-Path</codeph> to verify that the path doesn't go outside the locations you expect the task to access. Use <codeph translate="no" class="+ topic/ph pr-d/codeph ">Split-Path -Parent $path</codeph> to check that the resolved path has the desired path as a parent.</p><p class="- topic/p ">For more information, see <xref href="https://docs.microsoft.com/en-us/powershell/scripting/PowerShell-Scripting?view=powershell-6" format="html" scope="external" class="- topic/xref ">PowerShell Scripting</xref> and <xref href="https://blogs.msdn.microsoft.com/powershell/2008/09/30/powershells-security-guiding-principles/" scope="external" format="html" class="- topic/xref ">Powershell's Security Guiding Principles</xref>.</p></section><section class="- topic/section "><title class="- topic/title ">Bash</title><p class="- topic/p ">In Bash and other command shells, shell command injection takes advantage of poor shell implementations. Put quotations marks around arguments to prevent the vulnerable shells from evaluating them. </p><p class="- topic/p ">Because the <codeph translate="no" class="+ topic/ph pr-d/codeph ">eval</codeph> command evaluates all arguments with string substitution, avoid using it with user input; however you can use <codeph translate="no" class="+ topic/ph pr-d/codeph ">eval</codeph> with sufficient quoting to prevent substituted variables from being executed.</p><p class="- topic/p ">Instead of</p><codeblock translate="no" xml:space="preserve" class="+ topic/pre pr-d/codeblock ">eval "echo $input"</codeblock><p class="- topic/p ">use</p><codeblock translate="no" xml:space="preserve" class="+ topic/pre pr-d/codeblock ">eval "echo '$input'"</codeblock><p class="- topic/p ">These are operating system-specific tools to validate file paths: <codeph translate="no" class="+ topic/ph pr-d/codeph ">realpath</codeph> or <codeph translate="no" class="+ topic/ph pr-d/codeph ">readlink -f</codeph>. </p></section><section class="- topic/section "><title class="- topic/title "> Python </title><p class="- topic/p ">In Python malicious code can be introduced through commands like <codeph translate="no" class="+ topic/ph pr-d/codeph ">eval</codeph>, <codeph translate="no" class="+ topic/ph pr-d/codeph ">exec</codeph>, <codeph translate="no" class="+ topic/ph pr-d/codeph ">os.system</codeph>, <codeph translate="no" class="+ topic/ph pr-d/codeph ">os.popen</codeph>, and <codeph translate="no" class="+ topic/ph pr-d/codeph ">subprocess.call</codeph> with <codeph translate="no" class="+ topic/ph pr-d/codeph ">shell=True</codeph>. Use <codeph translate="no" class="+ topic/ph pr-d/codeph ">subprocess.call</codeph> with <codeph translate="no" class="+ topic/ph pr-d/codeph ">shell=False</codeph> when you include user input in a command or escape variables.</p><p class="- topic/p ">Instead of</p><codeblock translate="no" xml:space="preserve" class="+ topic/pre pr-d/codeblock ">os.system('echo '+input)
</codeblock><p class="- topic/p ">use</p><codeblock translate="no" xml:space="preserve" class="+ topic/pre pr-d/codeblock ">subprocess.check_output(['echo', input])</codeblock><p class="- topic/p ">Resolve file paths with <codeph translate="no" class="+ topic/ph pr-d/codeph ">os.realpath</codeph> and confirm them to be within another path by looping over <codeph translate="no" class="+ topic/ph pr-d/codeph ">os.path.dirname</codeph> and comparing to the desired path.</p><p class="- topic/p ">For more information on the vulnerabilities of Python or how to escape variables, see Kevin London's blog post on <xref href="https://www.kevinlondon.com/2015/07/26/dangerous-python-functions.html" format="html" scope="external" class="- topic/xref ">Dangerous Python Functions</xref>. </p></section><section class="- topic/section "><title class="- topic/title "> <ph conkeyref="ProductNames/ruby" class="- topic/ph "/> </title><p class="- topic/p ">In <ph conkeyref="ProductNames/ruby" class="- topic/ph "/>, command injection is introduced through commands like <codeph translate="no" class="+ topic/ph pr-d/codeph ">eval</codeph>, <codeph translate="no" class="+ topic/ph pr-d/codeph ">exec</codeph>, <codeph translate="no" class="+ topic/ph pr-d/codeph ">system</codeph>, backtick (``) or <codeph translate="no" class="+ topic/ph pr-d/codeph ">%x()</codeph> execution, or the Open3 module. You can safely call these functions with user input by passing the input as additional arguments instead of a single string. </p><p class="- topic/p ">Instead of</p><codeblock translate="no" xml:space="preserve" class="+ topic/pre pr-d/codeblock ">system("echo #{flag1} #{flag2}")</codeblock><p class="- topic/p ">use</p><codeblock translate="no" xml:space="preserve" class="+ topic/pre pr-d/codeblock ">system('echo', flag1, flag2)</codeblock><p class="- topic/p ">Resolve file paths with <codeph translate="no" class="+ topic/ph pr-d/codeph ">Pathname#realpath</codeph>, and confirm them to be within another path by looping over <codeph translate="no" class="+ topic/ph pr-d/codeph ">Pathname#parent</codeph> and comparing to the desired path.</p><p class="- topic/p ">For more information on securely passing user input, see the blog post <xref href="https://www.hilman.io/blog/2016/01/stop-using-backtick-to-run-shell-command-in-ruby/" scope="external" format="html" class="- topic/xref ">Stop using backtick to run shell command in Ruby</xref>.</p></section></conbody></concept>
