<!DOCTYPE concept PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept xmlns:ditaarch="http://dita.oasis-open.org/architecture/2005/" id="concept-5598" domains="(topic concept)                            (topic hi-d)                            (topic ut-d)                            (topic indexing-d)                             (topic pr-d)                            (topic sw-d)                            (topic ui-d)   " ditaarch:DITAArchVersion="1.2" class="- topic/topic concept/concept "><title class="- topic/title ">Target objects</title><shortdesc class="- topic/shortdesc "> The <codeph translate="no" class="+ topic/ph pr-d/codeph ">Target</codeph> object represents a node and its specific connection options. </shortdesc><prolog class="- topic/prolog "><author type="creator" translate="no" class="- topic/author ">Kate Lopresti &lt;kate.lopresti@puppet.com&gt;</author></prolog><conbody class="- topic/body  concept/conbody "><p class="- topic/p ">The state of a target is stored in the inventory for the duration of a plan allowing you to collect facts or set vars for a target and retrieve them later.&#160;You can get a printable representation via the <codeph translate="no" class="+ topic/ph pr-d/codeph ">name</codeph> function, as well as access components of the target: <codeph translate="no" class="+ topic/ph pr-d/codeph ">protocol, host, port, user, password</codeph>. </p><section class="- topic/section "><title class="- topic/title ">TargetSpec</title><p class="- topic/p ">The execution function takes a parameter with the type alias TargetSpec. This alias accepts the pattern strings allowed by&#160;<codeph translate="no" class="+ topic/ph pr-d/codeph ">--nodes</codeph>, a single Target object, or an Array of Targets and node patterns. Plans that accept a set of targets as a parameter should generally use this type to interact cleanly with the CLI and other plans. To operate on individual nodes, resolve it to a list via&#160;<codeph translate="no" class="+ topic/ph pr-d/codeph ">get_targets</codeph>. For example to loop over each node in a plan accept a&#160;<codeph translate="no" class="+ topic/ph pr-d/codeph ">TargetSpec</codeph>&#160;argument but call&#160;<codeph translate="no" class="+ topic/ph pr-d/codeph ">get_targets&#160;</codeph>on it before looping.</p><p class="- topic/p "><codeblock translate="no" xml:space="preserve" class="+ topic/pre pr-d/codeblock ">plan loop(TargetSpec $nodes) {
  get_targets($nodes).each |$target| {
    run_task('my_task', $target)
  }
}</codeblock></p><p class="- topic/p ">If your plan accepts a single&#160;<codeph translate="no" class="+ topic/ph pr-d/codeph ">TargetSpec</codeph>&#160;parameter you can call that parameter&#160;<codeph translate="no" class="+ topic/ph pr-d/codeph ">nodes</codeph>&#160;so that it can be specified with the&#160;<codeph translate="no" class="+ topic/ph pr-d/codeph ">--nodes</codeph>&#160;flag from the command line.</p></section><section class="- topic/section "><title class="- topic/title ">Variables and facts on targets</title><p class="- topic/p ">When <ph conkeyref="ProductNames/bolt" class="- topic/ph "/> runs, it loads transport config values, variables, and facts from the inventory. These can be accessed with the&#160;<codeph translate="no" class="+ topic/ph pr-d/codeph ">$target.facts()</codeph>&#160;and&#160;<codeph translate="no" class="+ topic/ph pr-d/codeph ">$target.vars()</codeph>&#160;functions. During the course of a plan, you can update the facts or variables for any target. Facts usually come from running&#160;<codeph translate="no" class="+ topic/ph pr-d/codeph ">facter</codeph>&#160;or another fact collection application on the target or from a fact store like <ph conkeyref="ProductNames/puppetdb" class="- topic/ph "/>. Variables are computed externally or assigned directly.</p><p class="- topic/p ">Set variables in a plan using&#160;<codeph translate="no" class="+ topic/ph pr-d/codeph ">$target.set_var</codeph>:</p><codeblock translate="no" xml:space="preserve" class="+ topic/pre pr-d/codeblock ">plan vars(String $host) {
	$target = get_targets($host)[0]
	$target.set_var('newly_provisioned', true)
	$targetvars = $target.vars
	run_command("echo 'Vars for ${host}: ${$targetvars}'", $host)
}
</codeblock><p class="- topic/p ">Or set&#160;variables&#160;in the inventory file using the&#160;<codeph translate="no" class="+ topic/ph pr-d/codeph ">vars</codeph>&#160;key at the group level.</p><codeblock xml:space="preserve" class="+ topic/pre pr-d/codeblock ">groups:
  - name: my_nodes
    nodes:
      - localhost
    vars:
      operatingsystem: windows
    config:
      transport: ssh</codeblock></section><section class="- topic/section "><title class="- topic/title ">Collect facts from the targets</title><p class="- topic/p ">The facts plan connects to the target and discovers facts. It then stores these facts on the targets in the inventory for later use. </p><p class="- topic/p ">The methods used to collect facts: </p><ul class="- topic/ul "><li class="- topic/li ">On <codeph translate="no" class="+ topic/ph pr-d/codeph ">ssh</codeph> targets, it runs a Bash script.</li><li class="- topic/li ">On <codeph translate="no" class="+ topic/ph pr-d/codeph ">winrm</codeph> targets, it runs a <ph conkeyref="ProductNames/powershell" class="- topic/ph "/> script.</li><li class="- topic/li ">On <codeph translate="no" class="+ topic/ph pr-d/codeph ">pcp</codeph> or targets where the <ph conkeyref="ProductNames/puppet" class="- topic/ph "/> agent is present, it runs <ph conkeyref="ProductNames/facter" class="- topic/ph "/>.</li></ul><p class="- topic/p ">This example collects facts with the facts plan and then uses those facts to decide which task to run on the targets.<codeblock translate="no" xml:space="preserve" class="+ topic/pre pr-d/codeblock ">plan run_with_facts(TargetSpec $nodes) {
  # This collects facts on nodes and update the inventory
  run_plan(facts, nodes =&gt; $nodes)

  $centos_nodes = get_targets($nodes).filter |$n| { $n.facts['os']['name'] == 'CentOS' }
  $ubuntu_nodes = get_targets($nodes).filter |$n| { $n.facts['os']['name'] == 'Ubuntu' }
  run_task(centos_task, $centos_nodes)
  run_task(ubuntu_task, $ubuntu_nodes)
}</codeblock> </p></section><section class="- topic/section "><title class="- topic/title ">Collect facts from <ph conkeyref="ProductNames/puppetdb" class="- topic/ph "/> </title><p class="- topic/p ">When targets are running a <ph conkeyref="ProductNames/puppet" class="- topic/ph "/> agent and sending facts to <ph conkeyref="ProductNames/puppetdb" class="- topic/ph "/>, you can use the&#160;<codeph translate="no" class="+ topic/ph pr-d/codeph ">puppetdb_fact</codeph>&#160;plan to collect facts for them. This example collects facts with the&#160;<codeph translate="no" class="+ topic/ph pr-d/codeph ">puppetdb_fact</codeph>&#160;plan, and then uses those facts to decide which task to run on the targets. You must configure the <ph conkeyref="ProductNames/puppetdb" class="- topic/ph "/> client before you run it.</p><codeblock translate="no" xml:space="preserve" class="+ topic/pre pr-d/codeblock ">plan run_with_facts(TargetSpec $nodes) {
  # This collects facts on nodes and update the inventory
  run_plan(<b class="+ topic/ph hi-d/b ">puppetdb_fact</b>, nodes =&gt; $nodes)

  $centos_nodes = get_targets($nodes).filter |$n| { $n.facts['os']['name'] == 'CentOS' }
  $ubuntu_nodes = get_targets($nodes).filter |$n| { $n.facts['os']['name'] == 'Ubuntu' }
  run_task(centos_task, $centos_nodes)
  run_task(ubuntu_task, $ubuntu_nodes)
}</codeblock></section></conbody></concept>
