<!DOCTYPE concept PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept xmlns:ditaarch="http://dita.oasis-open.org/architecture/2005/" id="concept-3038" domains="(topic concept)                            (topic hi-d)                            (topic ut-d)                            (topic indexing-d)                             (topic pr-d)                            (topic sw-d)                            (topic ui-d)   " ditaarch:DITAArchVersion="1.2" class="- topic/topic concept/concept "><title class="- topic/title ">How manifest blocks are applied</title><shortdesc class="- topic/shortdesc ">When you run a plan that contains a manifest block, the
         <codeph class="+ topic/ph pr-d/codeph ">apply_prep</codeph> function installs the packages
      necessary to run the <ph conkeyref="ProductNames/bolt" class="- topic/ph "/> <codeph class="+ topic/ph pr-d/codeph ">apply</codeph> command.</shortdesc><prolog class="- topic/prolog "><author type="creator" translate="no" class="- topic/author ">Kate Lopresti
         &lt;kate.lopresti@puppet.com&gt;</author></prolog><conbody class="- topic/body  concept/conbody "><p class="- topic/p ">The <codeph class="+ topic/ph pr-d/codeph ">apply_prep</codeph> function
         identifies the nodes that do not have <ph conkeyref="ProductNames/puppet" class="- topic/ph "/> agents and runs the <codeph translate="no" class="+ topic/ph pr-d/codeph ">puppet_agent::install</codeph> task (from the <xref href="https://forge.puppet.com/puppetlabs/puppet_agent" format="html" scope="external" class="- topic/xref ">puppet_agent module</xref>). It also copies over custom facts from
         the <ph conkeyref="ProductNames/bolt" class="- topic/ph "/> modulepath and runs <xref href="https://puppet.com/docs/facter/latest/" format="html" scope="external" class="- topic/xref ">facter</xref> on the target nodes. </p><p class="- topic/p ">Behind the scenes, <ph conkeyref="ProductNames/bolt" class="- topic/ph "/> compiles the code in your manifest block (the code wrapped in curly braces that follows
         the <codeph translate="no" class="+ topic/ph pr-d/codeph ">apply</codeph> function) into a
         catalog. Code is compiled in the following order: 

         <ul class="- topic/ul "><li class="- topic/li "> Facts<?ezd-review-end 4251ae2e-75f5-4819-98da-28885ac1946f?>
               gathered from the targets or set in your inventory. </li><li class="- topic/li "> Local variables in the plan, such as <codeph translate="no" class="+ topic/ph pr-d/codeph ">$site_content.</codeph>
            </li><li class="- topic/li ">
               <xref href="inventory_file.dita#concept-3383/title-1541705359297" class="- topic/xref ">
                  <codeph translate="no" class="+ topic/ph pr-d/codeph ">Vars</codeph>
               </xref> set in your inventory. 
            </li></ul></p><p class="- topic/p ">Like the code compiled with the <codeph class="+ topic/ph pr-d/codeph ">puppet apply</codeph> function, all the variables are generated. As a result, you can
         reuse code between <ph conkeyref="ProductNames/bolt" class="- topic/ph "/> and <ph conkeyref="ProductNames/puppet" class="- topic/ph "/>. <ph conkeyref="ProductNames/bolt" class="- topic/ph "/> then copies custom module content from the <ph conkeyref="ProductNames/bolt" class="- topic/ph "/> modulepath to the target nodes and
         applies the catalog using <ph conkeyref="ProductNames/puppet" class="- topic/ph "/>. </p><p class="- topic/p ">After the catalog compiles and is executed successfully on all targets,
            <codeph class="+ topic/ph pr-d/codeph ">apply</codeph> returns the reports generated by
         applying the catalog on each node.</p><section class="- topic/section "><title class="- topic/title ">Options for Apply
            action</title><p class="- topic/p ">The <codeph translate="no" class="+ topic/ph pr-d/codeph ">apply</codeph> action supports the following options:</p><p class="- topic/p ">
            <ul class="- topic/ul "><li class="- topic/li ">
                  <p class="- topic/p "><codeph translate="no" class="+ topic/ph pr-d/codeph ">_catch_errors =&gt; true</codeph> returns a <codeph translate="no" class="+ topic/ph pr-d/codeph ">ResultSet</codeph> including failed results,
                     rather than failing the plan. </p>
               </li><li class="- topic/li ">
                  <p class="- topic/p "><codeph translate="no" class="+ topic/ph pr-d/codeph ">_noop
                        =&gt; true</codeph> applies the manifest block in <ph conkeyref="ProductNames/puppet" class="- topic/ph "/> no-operation mode,
                     returning a report of the changes it would make, but takes no action.</p>
               </li><li class="- topic/li ">
                  <p class="- topic/p "><codeph translate="no" class="+ topic/ph pr-d/codeph ">_run_as =&gt; &lt;USER&gt;</codeph> applies the manifest block as the
                     specified user. (This option is for transports that allow a user to run
                     commands under a different username.)</p>

                  <codeblock xml:space="preserve" class="+ topic/pre pr-d/codeblock "># Preview installing docker as root on $nodes.
apply($nodes, _catch_errors =&gt; true, _noop =&gt; true, _run_as =&gt; root) {
   include 'docker'
}</codeblock>
               </li></ul>
         </p></section><section class="- topic/section "><title class="- topic/title ">Return value of Apply
            action</title><p class="- topic/p ">The <codeph translate="no" class="+ topic/ph pr-d/codeph ">apply</codeph> action returns an object type <codeph translate="no" class="+ topic/ph pr-d/codeph ">ResultSet</codeph> that contains
               <codeph translate="no" class="+ topic/ph pr-d/codeph ">ApplyResult</codeph> object
            for each target. For more information on the methods you can call on
               <codeph class="+ topic/ph pr-d/codeph ">$result</codeph>, see 

            <xref href="handling_plan_function_results.dita" class="- topic/xref "/>.</p><codeblock xml:space="preserve" class="+ topic/pre pr-d/codeblock ">$results = apply($nodes) { ... }
$results.each |$result| {
   notice($result.report)
}</codeblock></section><section class="- topic/section "><title class="- topic/title ">Configuring
            concurrency</title><p class="- topic/p "> Each target requires a separate catalog be
            compiled with its unique facts and <codeph translate="no" class="+ topic/ph pr-d/codeph ">Vars</codeph>. The apply action compiles and applies
            catalogs in parallel on the <ph conkeyref="ProductNames/bolt" class="- topic/ph "/>
            host. Concurrency of catalog compilation is controlled by a <codeph translate="no" class="+ topic/ph pr-d/codeph ">compile-concurrency</codeph> config option. This
            option is limited to twice the number of threads your CPU can run concurrently. Catalog
            application, on the other hand, uses the <ph conkeyref="ProductNames/bolt" class="- topic/ph "/> default thread pool controlled by the <codeph translate="no" class="+ topic/ph pr-d/codeph ">concurrency</codeph> option.</p></section></conbody></concept>
